
#### HW8-1:å…¨æºæœ€çŸ­è·¯

é¢˜ç›®ï¼š

- ç»™å®šä¸€ä¸ªåŒ…å«nä¸ªç»“ç‚¹å’Œmæ¡å¸¦æƒè¾¹çš„æœ‰å‘å›¾ï¼Œæ±‚æ‰€æœ‰ç‚¹å¯¹é—´çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œä¸€æ¡è·¯å¾„çš„é•¿åº¦å®šä¹‰ä¸ºè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰è¾¹çš„æƒå€¼å’Œã€‚
- $1â‰¤nâ‰¤3âˆ—10^3,1â‰¤mâ‰¤6âˆ—10^3,1â‰¤u,vâ‰¤n,âˆ’15000â‰¤wâ‰¤15000$
- æ³¨æ„ï¼š
  1. è¾¹æƒå¯èƒ½ä¸ºè´Ÿï¼Œä¸”å›¾ä¸­å¯èƒ½å­˜åœ¨é‡è¾¹å’Œè‡ªç¯ï¼›
  2. éƒ¨åˆ†æ•°æ®å¡nè½® SPFA ç®—æ³•ã€‚

è¾“å…¥:

- ç¬¬1è¡Œï¼š2ä¸ªæ•´æ•°n,mï¼Œè¡¨ç¤ºç»™å®šæœ‰å‘å›¾çš„ç»“ç‚¹æ•°é‡å’Œæœ‰å‘è¾¹æ•°é‡ã€‚
- æ¥ä¸‹æ¥mè¡Œï¼šæ¯è¡Œ3ä¸ªæ•´æ•°u,v,wï¼Œè¡¨ç¤ºæœ‰ä¸€æ¡æƒå€¼ä¸ºwçš„æœ‰å‘è¾¹ä»ç¼–å·ä¸ºuçš„ç»“ç‚¹è¿å‘ç¼–å·ä¸ºvçš„ç»“ç‚¹ã€‚

è¾“å‡º:

- è‹¥å›¾ä¸­å­˜åœ¨è´Ÿç¯ï¼Œè¾“å‡ºä»…ä¸€è¡Œâˆ’1ã€‚ 
- è‹¥å›¾ä¸­ä¸å­˜åœ¨è´Ÿç¯ï¼š
  - è¾“å‡ºnè¡Œï¼šä»¤$dis_{i,j}$ä¸ºä»iåˆ°jçš„æœ€çŸ­è·¯ï¼Œåœ¨ç¬¬iè¡Œè¾“å‡º$âˆ‘_{j=1}^njâˆ—dis_{i,j}$ï¼Œæ³¨æ„è¿™ä¸ªç»“æœå¯èƒ½è¶…è¿‡ int å­˜å‚¨èŒƒå›´ã€‚
  - å¦‚æœä¸å­˜åœ¨ä»ğ‘–åˆ°ğ‘—çš„è·¯å¾„ï¼Œåˆ™$dis_{i,j}=10^9$ï¼›å¦‚æœ$i=j$ï¼Œåˆ™$dis_{i,j}=0$.

![image-20240710173635069](C:\Users\24514\AppData\Roaming\Typora\typora-user-images\image-20240710173635069.png)![image-20240710173644479](C:\Users\24514\AppData\Roaming\Typora\typora-user-images\image-20240710173644479.png)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>

#define ll long long
using namespace std;
const int MAXN = 3010, INF = 1000000000;
priority_queue < pair<int, int> > q;
queue <int> qu;
int n, m, tot, tot2, x, y, z, d[MAXN][MAXN], vis[MAXN];
int hd[MAXN], ver[3 * MAXN], nx[3 * MAXN], edge[3 * MAXN];
int dis[MAXN], hd2[MAXN], ver2[6 * MAXN], nx2[6 * MAXN], edge2[6 * MAXN], vis2[MAXN], tim[MAXN];
struct Edge {
	Edge() { u = v = w = 0; }
	Edge(int a, int b, int c) { u = a, v = b, w = c; }
	int u, v, w;
}e[3 * MAXN];
void add_edge(int x, int y, int z) {
	ver[++tot] = y;
	edge[tot] = z, nx[tot] = hd[x];
	hd[x] = tot;
	return;
}
void add_edge1(int x, int y, int z) {
	ver2[++tot2] = y;
	edge2[tot2] = z, nx2[tot2] = hd2[x];
	hd2[x] = tot2;
	return;
}
bool spfa(int s) {
	dis[s] = 0, vis2[s] = 1;
	qu.push(s);
	while (!qu.empty()) {
		int a = qu.front();
		qu.pop();
		vis2[a] = 0;
		if (++tim[a] > n - 1) {
			return 0;
		}
		for (int i = hd2[a]; i; i = nx2[i]) {
			if (dis[ver2[i]] > dis[a] + edge2[i]) {
				dis[ver2[i]] = dis[a] + edge2[i];
				if (!vis2[ver2[i]]) {
					vis2[ver2[i]] = 1;
					qu.push(ver2[i]);
				}
			}
		}
	}
	return 1;
}
void dijkstra(int s) {
	memset(vis, 0, sizeof(vis));
	d[s][s] = 0;
	q.push(make_pair(0, s));
	while (!q.empty()) {
		pair <int, int> a = q.top();
		q.pop();
		if (vis[a.second]) { continue; }
		vis[a.second] = 1;
		for (int i = hd[a.second]; i; i = nx[i]) {
			if (d[s][ver[i]] > d[s][a.second] + edge[i]) {
				d[s][ver[i]] = d[s][a.second] + edge[i];
				q.push(make_pair(-d[s][ver[i]], ver[i]));
			}
		}
	}
}
int main() {
	memset(dis, 0x3f, sizeof(dis));
	memset(d, 0x3f, sizeof(d));
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) {
		scanf("%d%d%d", &x, &y, &z);
		add_edge1(x, y, z);
		if (z > 500000 || z < -500000) { printf("err\n"); return 0; }
		e[i] = Edge(x, y, z);
	}
	for (int i = 1; i <= n; i++) {
		add_edge1(n + 1, i, 0);
	}
	if (!spfa(n + 1)) {
		printf("-1\n");
		return 0;
	}
	for (int i = 1; i <= m; i++) {
		add_edge(e[i].u, e[i].v, e[i].w + dis[e[i].u] - dis[e[i].v]);
	}
	for (int i = 1; i <= n; i++) {
		dijkstra(i);
	}
	for (int i = 1; i <= n; i++) {
		ll ans = 0;
		for (int j = 1; j <= n; j++) {
			if (d[i][j] == 0x3f3f3f3f) { ans += 1ll * INF * j; }
			else { ans += 1ll * (d[i][j] - dis[i] + dis[j]) * j; }
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```
